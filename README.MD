# Daily Programming Problems
These are my solutions to the daily programming problems from a mailing list.

## Purpose
One of the most difficult (and possibly most cruel) parts of working in software development is the technical interview. Many consider the technical interview to be its own kind of skill, and thus it takes a certain kind of practice to help hone that skill. In order to make sure I do not get rusty with my abilities, and am able to show that I am employable, I will work on these daily programming problems. Plus, I like to do at least a little bit of programming every day, just to keep the juices flowing.

## Source of Questions
The questions I am getting are from [Daily Coding Problems](https://www.dailycodingproblem.com/) . My solutions are NOT the premium solutions, and any similarities between them are simply coincidence. I do not plan on paying for premium.

## Goal
There is not set goal of this repository except to be able to quickly go over problems and their solutions, as well as a location to store what I have worked on. Further, while I will be trying to make my solutions as space and time efficient as possible, I will not be paying for the premium solutions.  As a result, I will not 100% know if my solutions are the ideal solutions. I will offer an explanation for my solutions, and a short discussion on time and space considerations.

## Structure
For each question, the project will follow a similar explanation style to what is expected for a technical interview:

### Problem
First, I will restate the problem as given. I will make notes of what looks like key information and should be remembered.
### Clarify Requirements
Then, I will go over the requirements and what they might be hinting me towards.
### Mental Simple Solution
After clarifying the requirements, I will propose a simple solution. This solution will probably be a brute force method and will not be optimized.
### Optimization
With a brute force method in mind, I will go over ways to optimize.
### Code Final Solution
With the optimized solution in mind, I will code a final solution. I will also discuss any hacks/trade offs/weird language choices in this section.
### Testing
Discussion of how I know I have a good solution.
### Quality of Answer
This is hard section to define, but it is to discuss space and time requirements of my solution. It will make qualitative judgements on them, and might even help point me to a better solution.